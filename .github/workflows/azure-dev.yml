# ==============================================================================
# AZURE DEVELOPER CLI (azd) CI/CD PIPELINE
# ==============================================================================
#
# Purpose:      Automated infrastructure provisioning and application deployment
#               for the Azure Logic Apps Monitoring solution.
#
# Triggers:     - Push to main branch (continuous deployment)
#               - Manual workflow dispatch (on-demand deployment)
#
# Architecture: Uses Azure Developer CLI (azd) with .NET Aspire for:
#               ‚îú‚îÄ‚îÄ Infrastructure provisioning (Bicep/ARM)
#               ‚îî‚îÄ‚îÄ Application deployment (Container Apps)
#
# Security:     Implements OIDC federated credentials (passwordless auth)
#               No secrets stored in GitHub - uses Azure Managed Identity
#
# Prerequisites:
#   GitHub Repository Variables (Settings ‚Üí Secrets and Variables ‚Üí Actions):
#   - AZURE_CLIENT_ID       : Service Principal/App Registration Client ID
#   - AZURE_TENANT_ID       : Azure AD Tenant ID
#   - AZURE_SUBSCRIPTION_ID : Target Azure Subscription ID
#   - AZURE_LOCATION        : Azure region for deployment (e.g., eastus2)
#   - AZURE_ENV_NAME        : Environment name (e.g., dev, staging, prod)
#
# Documentation:
#   - azd:  https://learn.microsoft.com/azure/developer/azure-developer-cli/
#   - OIDC: https://learn.microsoft.com/azure/developer/github/connect-from-azure
#
# Author:       Evilazaro
# Repository:   https://github.com/Evilazaro/Azure-LogicApps-Monitoring
# ==============================================================================

# ------------------------------------------------------------------------------
# WORKFLOW METADATA
# ------------------------------------------------------------------------------
name: "Azure Developer CLI - Provision & Deploy"

# ------------------------------------------------------------------------------
# TRIGGER CONFIGURATION
# ------------------------------------------------------------------------------
# Workflow executes on:
#   1. Push events to the main branch (automated CI/CD)
#   2. Manual trigger via GitHub Actions UI (workflow_dispatch)
on:
  workflow_dispatch:
    # Manual trigger with optional inputs for flexibility
    inputs:
      environment:
        description: "Target deployment environment"
        required: false
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod

  push:
    # Trigger on commits to the mainline branch
    branches:
      - main
    # Optimize by ignoring non-code changes
    paths-ignore:
      - "**.md"
      - "docs/**"
      - ".gitignore"
      - "LICENSE"

# ------------------------------------------------------------------------------
# CONCURRENCY CONTROL
# ------------------------------------------------------------------------------
# Prevents concurrent deployments to the same environment.
# Queues new runs and cancels in-progress runs for the same branch.
# This ensures infrastructure consistency and prevents race conditions.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# ------------------------------------------------------------------------------
# SECURITY PERMISSIONS
# ------------------------------------------------------------------------------
# Minimal permissions following principle of least privilege.
# - id-token: write  ‚Üí Required for OIDC federated credential authentication
# - contents: read   ‚Üí Required for repository checkout
# - statuses: write  ‚Üí Required to report deployment status checks
# - checks: write    ‚Üí Required for test-reporter to create check runs
# Reference: https://docs.github.com/en/actions/security-guides/automatic-token-authentication
permissions:
  id-token: write
  contents: read
  statuses: write
  checks: write

# ------------------------------------------------------------------------------
# JOBS DEFINITION
# ------------------------------------------------------------------------------
jobs:
  # ============================================================================
  # JOB: provision-and-deploy
  # ============================================================================
  # Provisions Azure infrastructure and deploys the application using azd.
  # Combines both operations in a single job for efficiency with azd workflows.
  # ============================================================================
  provision-and-deploy:
    name: "üöÄ Provision & Deploy to Azure"
    runs-on: ubuntu-latest

    # --------------------------------------------------------------------------
    # Job timeout - Prevents runaway jobs from consuming resources
    # Infrastructure provisioning may take 15-20 minutes for complex deployments
    # --------------------------------------------------------------------------
    timeout-minutes: 45

    # --------------------------------------------------------------------------
    # Environment configuration for deployment protection rules
    # Enables environment-specific secrets and approval workflows
    # --------------------------------------------------------------------------
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}
      url: ${{ steps.deploy.outputs.webapp_url }}

    # --------------------------------------------------------------------------
    # Environment variables from GitHub repository variables
    # These are NOT secrets - they are configuration values
    # --------------------------------------------------------------------------
    env:
      AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
      AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}
      DEPLOYER_PRINCIPAL_TYPE: ServicePrincipal
      DEPLOY_HEALTH_MODEL: false

    steps:
      # ------------------------------------------------------------------------
      # Step 1: Checkout repository
      # ------------------------------------------------------------------------
      # Clones the repository code for build and deployment.
      # fetch-depth: 0 provides full history for version detection if needed.
      # ------------------------------------------------------------------------
      - name: "üì• Checkout repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------------------
      # Step 2: Setup .NET SDK
      # ------------------------------------------------------------------------
      # Installs required .NET SDK versions for building .NET Aspire projects.
      # Multiple versions support different project target frameworks.
      # ------------------------------------------------------------------------
      - name: "üîß Setup .NET SDK"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            8.x
            9.x
            10.x

      # ------------------------------------------------------------------------
      # Step 3: Restore NuGet packages
      # ------------------------------------------------------------------------
      # Downloads all NuGet dependencies defined in project files.
      # ------------------------------------------------------------------------
      - name: "üì¶ Restore dependencies"
        run: dotnet restore app.sln --verbosity minimal

      # ------------------------------------------------------------------------
      # Step 4: Build .NET solution
      # ------------------------------------------------------------------------
      # Compiles all projects in Release configuration to validate code.
      # This ensures the application compiles before attempting deployment.
      # ------------------------------------------------------------------------
      - name: "üèóÔ∏è Build .NET solution"
        run: dotnet build app.sln --configuration Release --no-restore /p:TreatWarningsAsErrors=false

      # ------------------------------------------------------------------------
      # Step 5: Run unit tests
      # ------------------------------------------------------------------------
      # Executes all unit tests to validate code correctness before deployment.
      # Fails fast to prevent expensive provisioning if tests fail.
      # continue-on-error: Allows result parsing and summary generation.
      # Note: Uses --report-trx for MSTest.Sdk projects with TrxReport extension.
      # ------------------------------------------------------------------------
      - name: "üß™ Run unit tests"
        id: test
        continue-on-error: true
        run: |
          # Create TestResults directory to ensure it exists
          mkdir -p TestResults

          # Run tests with TRX reporter enabled
          # MSTest.Sdk with Microsoft.Testing.Extensions.TrxReport uses --report-trx
          dotnet test app.sln \
            --configuration Release \
            --verbosity normal \
            --results-directory TestResults \
            -- --report-trx --report-trx-filename test-results.trx

          TEST_EXIT_CODE=$?

          # Debug: List test results
          echo "::group::Test Results Directory Contents"
          echo "Looking for TRX files..."
          find . -name "*.trx" -type f 2>/dev/null || echo "No TRX files found with find"
          echo "TestResults directory:"
          ls -la TestResults/ 2>/dev/null || echo "TestResults directory not found or empty"
          echo "::endgroup::"

          exit $TEST_EXIT_CODE
      # Parses total, passed, failed, and skipped test counts.
      # ------------------------------------------------------------------------
      - name: "üìä Parse test results"
        id: test-results
        if: always()
        run: |
          # Initialize counters
          TOTAL=0
          PASSED=0
          FAILED=0
          SKIPPED=0
          DURATION="0s"

          # Find and parse TRX files
          if [ -d "TestResults" ]; then
            for trx in TestResults/*.trx; do
              if [ -f "$trx" ]; then
                echo "Parsing: $trx"
                
                # Extract test counts from TRX XML
                COUNTERS=$(grep -oP '<Counters[^>]+>' "$trx" | head -1 || echo "")
                
                if [ -n "$COUNTERS" ]; then
                  FILE_TOTAL=$(echo "$COUNTERS" | grep -oP 'total="\K[0-9]+' || echo "0")
                  FILE_PASSED=$(echo "$COUNTERS" | grep -oP 'passed="\K[0-9]+' || echo "0")
                  FILE_FAILED=$(echo "$COUNTERS" | grep -oP 'failed="\K[0-9]+' || echo "0")
                  FILE_SKIPPED=$(echo "$COUNTERS" | grep -oP 'notExecuted="\K[0-9]+' || echo "0")
                  
                  TOTAL=$((TOTAL + FILE_TOTAL))
                  PASSED=$((PASSED + FILE_PASSED))
                  FAILED=$((FAILED + FILE_FAILED))
                  SKIPPED=$((SKIPPED + FILE_SKIPPED))
                fi
              fi
            done
          fi

          # Set outputs
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          echo "skipped=$SKIPPED" >> $GITHUB_OUTPUT

          # Log results
          echo "::group::Test Results Summary"
          echo "Total:   $TOTAL"
          echo "Passed:  $PASSED"
          echo "Failed:  $FAILED"
          echo "Skipped: $SKIPPED"
          echo "::endgroup::"

          # Fail if tests failed
          if [ "$FAILED" -gt 0 ]; then
            echo "::error::$FAILED test(s) failed"
          fi
        shell: bash

      # ------------------------------------------------------------------------
      # Step 7: Upload test results
      # ------------------------------------------------------------------------
      # Uploads test results as artifacts for analysis.
      # Runs always to capture results even on test failures.
      # ------------------------------------------------------------------------
      - name: "üì§ Upload test results"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: deployment-test-results
          path: TestResults
          retention-days: 14
          if-no-files-found: warn

      # ------------------------------------------------------------------------
      # Step 8: Generate test report (PR annotations)
      # ------------------------------------------------------------------------
      # Creates a test report with inline annotations for failed tests.
      # Uses dorny/test-reporter for rich GitHub integration.
      # Only runs if TRX files exist to avoid errors.
      # ------------------------------------------------------------------------
      - name: "üìù Generate test report"
        uses: dorny/test-reporter@v1
        if: always() && hashFiles('TestResults/*.trx') != ''
        with:
          name: "Deployment - Unit Test Results"
          path: "TestResults/*.trx"
          reporter: dotnet-trx
          fail-on-error: false

      # ------------------------------------------------------------------------
      # Step 9: Fail if tests failed (gate deployment)
      # ------------------------------------------------------------------------
      # Stops deployment if unit tests failed.
      # This is a critical gate to prevent deploying broken code.
      # ------------------------------------------------------------------------
      - name: "üö® Gate: Check test results"
        if: steps.test.outcome == 'failure'
        run: |
          echo "::error::Unit tests failed. Deployment blocked."
          echo "## ‚ùå Deployment Blocked" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Unit tests failed. Fix test failures before deployment." >> $GITHUB_STEP_SUMMARY
          exit 1

      # ------------------------------------------------------------------------
      # Step 10: Setup Azure CLI and Bicep
      # ------------------------------------------------------------------------
      # Azure CLI with Bicep for infrastructure template validation.
      # ------------------------------------------------------------------------
      - name: "üîß Setup Azure CLI and Bicep"
        uses: azure/cli@v2
        with:
          inlineScript: |
            az --version
            az bicep install
            az bicep version

      # ------------------------------------------------------------------------
      # Step 11: Build Bicep templates
      # ------------------------------------------------------------------------
      # Validates infrastructure templates compile before provisioning.
      # This catches syntax errors before attempting deployment.
      # ------------------------------------------------------------------------
      - name: "üèóÔ∏è Build Bicep templates"
        uses: azure/cli@v2
        with:
          inlineScript: |
            az bicep install
            echo "Building infra/main.bicep..."
            az bicep build --file infra/main.bicep --stdout > /dev/null
            echo "‚úÖ infra/main.bicep compiled successfully"

      # ------------------------------------------------------------------------
      # Step 12: Install Azure Developer CLI (azd)
      # ------------------------------------------------------------------------
      # Installs the latest version of azd for infrastructure management.
      # azd provides a unified experience for provisioning and deployment.
      # ------------------------------------------------------------------------
      - name: "üõ†Ô∏è Install Azure Developer CLI"
        uses: Azure/setup-azd@v2

      # ------------------------------------------------------------------------
      # Step 13: Install sqlcmd utility
      # ------------------------------------------------------------------------
      # Installs the Go version of sqlcmd for SQL Database managed identity
      # configuration in post-provisioning hooks.
      # ------------------------------------------------------------------------
      - name: "üõ†Ô∏è Install sqlcmd"
        run: |
          # Install sqlcmd (Go version) via direct download
          curl -sSL -o sqlcmd.tar.bz2 https://github.com/microsoft/go-sqlcmd/releases/latest/download/sqlcmd-linux-amd64.tar.bz2
          sudo tar -xjf sqlcmd.tar.bz2 -C /usr/local/bin
          rm sqlcmd.tar.bz2
          sqlcmd --version || echo "sqlcmd installation verification failed"
        continue-on-error: true

      # ------------------------------------------------------------------------
      # Step 14: Make hook scripts executable
      # ------------------------------------------------------------------------
      # Ensures shell scripts in hooks directory have execute permissions.
      # Required for azd lifecycle hooks to run on Linux runners.
      # ------------------------------------------------------------------------
      - name: "üîë Make hook scripts executable"
        run: chmod +x ./hooks/*.sh

      # ------------------------------------------------------------------------
      # Step 15: Authenticate with Azure using OIDC
      # ------------------------------------------------------------------------
      # Uses OpenID Connect (OIDC) federated credentials for passwordless auth.
      # No secrets are stored in GitHub - authentication is handled via
      # Azure AD workload identity federation.
      #
      # Prerequisites:
      #   1. App Registration with Federated Credential configured
      #   2. Federated credential subject: repo:<owner>/<repo>:environment:<env>
      #   3. Service Principal with appropriate RBAC roles
      # ------------------------------------------------------------------------
      - name: "üîê Authenticate Azure CLI (OIDC)"
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: "üîê Authenticate Azure Developer CLI (OIDC)"
        run: |
          azd auth login `
            --client-id "$Env:AZURE_CLIENT_ID" `
            --federated-credential-provider "github" `
            --tenant-id "$Env:AZURE_TENANT_ID"
        shell: pwsh

      # ------------------------------------------------------------------------
      # Step 16: Provision Azure Infrastructure
      # ------------------------------------------------------------------------
      # Deploys infrastructure using Bicep templates defined in /infra.
      # --no-prompt: Runs non-interactively for CI/CD automation.
      #
      # Resources provisioned (defined in infra/main.bicep):
      #   - Azure Container Apps Environment
      #   - Azure Container Registry
      #   - Azure Key Vault
      #   - Azure Logic Apps (Standard)
      #   - Supporting networking and monitoring resources
      # ------------------------------------------------------------------------
      - name: "‚òÅÔ∏è Provision Azure Infrastructure"
        run: azd provision --no-prompt
        env:
          # Override environment name if provided via workflow dispatch
          AZURE_ENV_NAME: ${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}

      # ------------------------------------------------------------------------
      # Step 17: Deploy Application
      # ------------------------------------------------------------------------
      # Deploys application code to provisioned Azure resources.
      # Uses .NET Aspire manifest for service discovery and configuration.
      #
      # Deployed services (defined in azure.yaml):
      #   - eShop.Orders.API: REST API for order management
      #   - eShop.Web.App: Frontend web application
      # ------------------------------------------------------------------------
      - name: "üö¢ Deploy Application"
        id: deploy
        run: |
          azd deploy --no-prompt
          # Output the web app URL for environment link
          echo "webapp_url=$(azd env get-values --output json | jq -r '.WEBAPP_URL // empty')" >> $GITHUB_OUTPUT
        shell: bash
        env:
          AZURE_ENV_NAME: ${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}

      # ------------------------------------------------------------------------
      # Step 18: Generate Deployment Summary
      # ------------------------------------------------------------------------
      # Creates a GitHub Actions job summary with deployment details.
      # Includes actual test results from TRX parsing.
      # Runs always to provide visibility even on failures.
      # ------------------------------------------------------------------------
      - name: "üìã Generate Deployment Summary"
        if: always()
        run: |
          # Get test results from earlier step
          TOTAL="${{ steps.test-results.outputs.total || '0' }}"
          PASSED="${{ steps.test-results.outputs.passed || '0' }}"
          FAILED="${{ steps.test-results.outputs.failed || '0' }}"
          SKIPPED="${{ steps.test-results.outputs.skipped || '0' }}"

          # Determine test status
          if [ "$FAILED" -gt 0 ]; then
            TEST_STATUS="‚ùå $FAILED Failed"
          elif [ "$TOTAL" -eq 0 ]; then
            TEST_STATUS="‚ö†Ô∏è No Tests"
          else
            TEST_STATUS="‚úÖ $PASSED Passed"
          fi

          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üèóÔ∏è Build Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| .NET Build | ‚úÖ Compiled |" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | $TEST_STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "| Bicep Build | ‚úÖ Validated |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show test details if tests ran
          if [ "$TOTAL" -gt 0 ]; then
            echo "### üß™ Test Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚úÖ Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚ùå Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚è≠Ô∏è Skipped | $SKIPPED |" >> $GITHUB_STEP_SUMMARY
            if [ "$TOTAL" -gt 0 ]; then
              PASS_PCT=$((PASSED * 100 / TOTAL))
              echo "| **Pass Rate** | $PASS_PCT% |" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "### üìä Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ job.status == 'success' && '‚úÖ Success' || job.status == 'cancelled' && '‚ö†Ô∏è Cancelled' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | \`${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Region** | \`${{ vars.AZURE_LOCATION }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Subscription** | \`${{ vars.AZURE_SUBSCRIPTION_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Run Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered By** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger Event** | \`${{ github.event_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit SHA** | [\`${GITHUB_SHA:0:7}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}) |" >> $GITHUB_STEP_SUMMARY
          echo "| **Workflow Run** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "### ‚úÖ Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The application has been deployed to the **${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}** environment." >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ job.status }}" == "cancelled" ]]; then
            echo "### ‚ö†Ô∏è Deployment was cancelled" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Deployment failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> **Troubleshooting:** Check the logs above for error details." >> $GITHUB_STEP_SUMMARY
          fi
        shell: bash
