# ==============================================================================
# AZURE DEVELOPER CLI (azd) CI/CD PIPELINE
# ==============================================================================
#
# Purpose:      Automated CI validation, infrastructure provisioning, and
#               application deployment for the Azure Logic Apps Monitoring solution.
#
# Triggers:     - Push to main branch (continuous deployment)
#               - Manual workflow dispatch (on-demand deployment with environment selection)
#
# Pipeline Flow:
#               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#               ‚îÇ CI Validation (gates deployment)                            ‚îÇ
#               ‚îÇ   ‚îú‚îÄ‚îÄ .NET Build: Compiles all projects                     ‚îÇ
#               ‚îÇ   ‚îú‚îÄ‚îÄ Unit Tests: Runs tests with TRX reporting             ‚îÇ
#               ‚îÇ   ‚îî‚îÄ‚îÄ Bicep Build: Validates infrastructure templates       ‚îÇ
#               ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
#               ‚îÇ Provisioning & Deployment (runs if CI passes)               ‚îÇ
#               ‚îÇ   ‚îú‚îÄ‚îÄ Azure Infrastructure: Provisions via azd/Bicep        ‚îÇ
#               ‚îÇ   ‚îî‚îÄ‚îÄ Application: Deploys to Azure Container Apps          ‚îÇ
#               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#
# Security:     Implements OIDC federated credentials (passwordless auth)
#               No secrets stored in GitHub - uses Azure Managed Identity
#
# Prerequisites:
#   GitHub Repository Variables (Settings ‚Üí Secrets and Variables ‚Üí Actions):
#   - AZURE_CLIENT_ID        : Service Principal/App Registration Client ID
#   - AZURE_TENANT_ID        : Azure AD Tenant ID
#   - AZURE_SUBSCRIPTION_ID  : Target Azure Subscription ID
#   - AZURE_LOCATION         : Azure region for deployment (e.g., eastus2)
#   - AZURE_ENV_NAME         : Environment name (e.g., dev, staging, prod)
#   - DEPLOYER_PRINCIPAL_TYPE: Principal type for deployment (e.g., ServicePrincipal)
#
# Documentation:
#   - azd:  https://learn.microsoft.com/azure/developer/azure-developer-cli/
#   - OIDC: https://learn.microsoft.com/azure/developer/github/connect-from-azure
#
# Author:       Evilazaro
# Repository:   https://github.com/Evilazaro/Azure-LogicApps-Monitoring
# ==============================================================================

# ------------------------------------------------------------------------------
# WORKFLOW METADATA
# ------------------------------------------------------------------------------
name: "CI/CD: Azure Provision & Deploy"

# ------------------------------------------------------------------------------
# TRIGGER CONFIGURATION
# ------------------------------------------------------------------------------
# Workflow executes on:
#   1. Push events to the main branch (automated CI/CD)
#   2. Manual trigger via GitHub Actions UI (workflow_dispatch)
on:
  workflow_dispatch:
    # Manual trigger with optional inputs for flexibility
    inputs:
      environment:
        description: "Target deployment environment"
        required: false
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod

  pull_request:
    branches:
      - main

# ------------------------------------------------------------------------------
# CONCURRENCY CONTROL
# ------------------------------------------------------------------------------
# Prevents concurrent deployments to the same environment.
# Queues new runs and cancels in-progress runs for the same branch.
# This ensures infrastructure consistency and prevents race conditions.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# ------------------------------------------------------------------------------
# SECURITY PERMISSIONS
# ------------------------------------------------------------------------------
# Minimal permissions following principle of least privilege.
# - id-token: write  ‚Üí Required for OIDC federated credential authentication
# - contents: read   ‚Üí Required for repository checkout
# - statuses: write  ‚Üí Required to report deployment status checks
# - checks: write    ‚Üí Required for test-reporter to create check runs
# Reference: https://docs.github.com/en/actions/security-guides/automatic-token-authentication
permissions:
  id-token: write
  contents: read
  statuses: write
  checks: write
  actions: read

# ------------------------------------------------------------------------------
# JOBS DEFINITION
# ------------------------------------------------------------------------------
jobs:
  # ============================================================================
  # JOB: provision-and-deploy
  # ============================================================================
  # Validates code, provisions Azure infrastructure, and deploys the application.
  # Combines CI validation and deployment in a single job for efficiency.
  #
  # Steps performed:
  #   1. Update Linux packages (install unzip)
  #   2. Checkout repository
  #   3. Setup .NET SDK (8.x, 9.x, 10.x)
  #   4. Update .NET Workloads
  #   5. Cache NuGet packages
  #   6. Restore dependencies
  #   7. Build .NET solution
  #   8. Run unit tests (gate deployment)
  #   9. Parse test results
  #  10. Upload test results artifact
  #  11. Generate test report
  #  12. Gate: Check test results
  #  13. Setup Azure CLI and Bicep
  #  14. Build Bicep templates
  #  15. Install Azure Developer CLI
  #  16. Install sqlcmd utility
  #  17. Make hook scripts executable
  #  18. Authenticate Azure CLI (OIDC)
  #  19. Authenticate Azure Developer CLI
  #  20. Provision Azure Infrastructure
  #  21. Re-authenticate Azure CLI (Token Refresh)
  #  22. Deploy Application
  #  23. Generate Deployment Summary
  # ============================================================================
  provision-and-deploy:
    name: "üöÄ Provision & Deploy to Azure"
    runs-on: ubuntu-latest

    # --------------------------------------------------------------------------
    # Job timeout - Prevents runaway jobs from consuming resources
    # Infrastructure provisioning may take 15-20 minutes for complex deployments
    # --------------------------------------------------------------------------
    timeout-minutes: 45

    # --------------------------------------------------------------------------
    # Environment configuration for deployment protection rules
    # Enables environment-specific secrets and approval workflows
    # --------------------------------------------------------------------------
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}
      url: ${{ steps.deploy.outputs.webapp_url }}

    # --------------------------------------------------------------------------
    # Environment variables from GitHub repository variables
    # These are NOT secrets - they are configuration values
    # --------------------------------------------------------------------------
    env:
      AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
      AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}
      DEPLOYER_PRINCIPAL_TYPE: "ServicePrincipal"
      DEPLOY_HEALTH_MODEL: false

    steps:
      # ------------------------------------------------------------------------
      # Step 1: Install required tools
      # ------------------------------------------------------------------------
      # Updates apt package list and installs unzip utility.
      # Required for extracting certain .NET workload components.
      # ------------------------------------------------------------------------
      - name: "üì¶ Install required tools"
        run: |
          echo "Installing required tools..."
          sudo apt-get update
          sudo apt-get install -y unzip

      # ------------------------------------------------------------------------
      # Step 2: Checkout repository
      # ------------------------------------------------------------------------
      # Clones the repository code for build and deployment.
      # fetch-depth: 0 provides full history for version detection if needed.
      # ------------------------------------------------------------------------
      - name: "üì• Checkout repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------------------
      # Step 3: Setup .NET SDK
      # ------------------------------------------------------------------------
      # Installs multiple .NET SDK versions required for building:
      #   - .NET 8.x: LTS version for backward compatibility
      #   - .NET 9.x: Current stable version
      #   - .NET 10.x: Preview version for .NET Aspire projects
      # ------------------------------------------------------------------------
      - name: "üîß Setup .NET SDK"
        id: setup-dotnet
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            8.x
            9.x
            10.x

      # ------------------------------------------------------------------------
      # Step 4: Update .NET Workloads
      # ------------------------------------------------------------------------
      # Updates .NET workloads (including Aspire) to ensure all required
      # components are available for building the solution.
      # ------------------------------------------------------------------------
      - name: "üõ†Ô∏è Install .NET Aspire and update Workloads"
        run: |
          echo "Installing .NET Aspire workload:"
          sudo dotnet workload install aspire --skip-manifest-update || echo "Aspire workload already installed"
          echo "Updating .NET Workloads:"
          sudo dotnet workload update

      # ------------------------------------------------------------------------
      # Step 5: Cache NuGet packages
      # ------------------------------------------------------------------------
      # Caches NuGet packages to speed up subsequent builds.
      # Cache key includes OS and hash of project/solution files for invalidation.
      # ------------------------------------------------------------------------
      - name: "üíæ Cache NuGet packages"
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.sln') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      # ------------------------------------------------------------------------
      # Step 6: Restore NuGet packages
      # ------------------------------------------------------------------------
      # Downloads all NuGet dependencies defined in project files.
      # Uses cached packages from previous runs when available.
      # ------------------------------------------------------------------------
      - name: "üì¶ Restore dependencies"
        id: restore
        run: dotnet restore app.sln --verbosity minimal

      # ------------------------------------------------------------------------
      # Step 7: Build .NET solution
      # ------------------------------------------------------------------------
      # Compiles all projects in Release configuration to validate code.
      #   --no-restore: Uses packages from previous step for efficiency
      #   TreatWarningsAsErrors=false: Allows warnings during build
      # This ensures the application compiles before attempting deployment.
      # ------------------------------------------------------------------------
      - name: "üèóÔ∏è Build .NET solution"
        id: build
        run: dotnet build app.sln --configuration Release --no-restore /p:TreatWarningsAsErrors=false

      # ------------------------------------------------------------------------
      # Step 8: Run unit tests
      # ------------------------------------------------------------------------
      # Executes unit tests to validate code correctness before deployment.
      # Gates deployment - tests must pass before provisioning expensive resources.
      # Uses TRX logger for test result reporting and GitHub integration.
      # continue-on-error: Allows subsequent steps to parse and report results.
      #
      # NOTE: app.Host.Tests is excluded because it contains .NET Aspire integration
      # tests that require Docker containers. These tests run locally with Docker
      # Desktop but fail in CI without proper container infrastructure.
      # ------------------------------------------------------------------------
      - name: "üß™ Run unit tests"
        id: test
        continue-on-error: true
        run: |
          # Create TestResults directory to ensure it exists
          mkdir -p TestResults

          echo "::group::Environment Information"
          echo "Working directory: $(pwd)"
          echo ".NET SDK version: $(dotnet --version)"
          echo "Available test projects:"
          find . -name "*.Tests.csproj" -type f | head -20
          echo "::endgroup::"

          # Run unit tests excluding Aspire integration tests (app.Host.Tests)
          # which require Docker containers that aren't available in CI.
          # Using --logger "trx;LogFileName=TestResults.trx" for consistent TRX output
          echo "::group::Running Tests"
          dotnet test app.sln \
            --configuration Release \
            --no-build \
            --verbosity normal \
            --logger "console;verbosity=detailed" \
            --logger "trx;LogFilePrefix=TestResults" \
            --results-directory TestResults \
            --filter "FullyQualifiedName!~app.Host.Tests"

          TEST_EXIT_CODE=$?
          echo "Test exit code: $TEST_EXIT_CODE"
          echo "::endgroup::"

          # Collect all TRX files from various locations into TestResults folder
          echo "::group::Collecting TRX Files"
          # Copy TRX files from bin directories (MSTest SDK projects)
          find . -path "*/bin/*/TestResults/*.trx" -type f -exec cp -v {} TestResults/ \; 2>/dev/null || true
          # Copy TRX files from obj directories if any
          find . -path "*/obj/*/TestResults/*.trx" -type f -exec cp -v {} TestResults/ \; 2>/dev/null || true
          echo ""
          echo "TRX files in TestResults directory:"
          ls -la TestResults/*.trx 2>/dev/null || echo "No TRX files found in TestResults/"
          echo ""
          echo "Total TRX files found in workspace:"
          find . -name "*.trx" -type f 2>/dev/null | head -20
          echo "::endgroup::"

          # If tests failed, show detailed failure information
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "::group::‚ùå Test Failure Details"
            echo "Tests failed with exit code: $TEST_EXIT_CODE"
            # Parse TRX files to show failed test names
            for trx in TestResults/*.trx; do
              if [ -f "$trx" ]; then
                FAILED_TESTS=$(grep -oP 'testName="\K[^"]+(?="[^>]*outcome="Failed")' "$trx" 2>/dev/null || true)
                if [ -n "$FAILED_TESTS" ]; then
                  echo ""
                  echo "Failed tests in $(basename "$trx"):"
                  echo "$FAILED_TESTS" | while read -r test; do
                    echo "  ‚ùå $test"
                  done
                fi
              fi
            done
            echo "::endgroup::"
          fi

          exit $TEST_EXIT_CODE

      # ------------------------------------------------------------------------
      # Step 9: Parse test results
      # ------------------------------------------------------------------------
      # Extracts test metrics from TRX files for job summary.
      # Parses total, passed, failed, and skipped test counts from each TRX file.
      # Sets step outputs (total, passed, failed, skipped, project_results)
      # for use in summary generation and deployment gating.
      # ------------------------------------------------------------------------
      - name: "üìä Parse test results"
        id: test-results
        if: always()
        run: |
          # Initialize counters
          TOTAL=0
          PASSED=0
          FAILED=0
          SKIPPED=0

          # Arrays for per-project results (stored as delimited strings for GITHUB_OUTPUT)
          PROJECT_RESULTS=""

          # Find and parse TRX files
          if [ -d "TestResults" ]; then
            for trx in TestResults/*.trx; do
              if [ -f "$trx" ]; then
                # Extract project name from TRX filename (format: ProjectName.trx)
                FILENAME=$(basename "$trx" .trx)
                PROJECT_NAME="$FILENAME"
                
                echo "Parsing: $trx (Project: $PROJECT_NAME)"
                
                # Extract test counts from TRX XML
                COUNTERS=$(grep -oP '<Counters[^>]+>' "$trx" | head -1 || echo "")
                
                if [ -n "$COUNTERS" ]; then
                  FILE_TOTAL=$(echo "$COUNTERS" | grep -oP 'total="\K[0-9]+' || echo "0")
                  FILE_PASSED=$(echo "$COUNTERS" | grep -oP 'passed="\K[0-9]+' || echo "0")
                  FILE_FAILED=$(echo "$COUNTERS" | grep -oP 'failed="\K[0-9]+' || echo "0")
                  FILE_SKIPPED=$(echo "$COUNTERS" | grep -oP 'notExecuted="\K[0-9]+' || echo "0")
                  
                  TOTAL=$((TOTAL + FILE_TOTAL))
                  PASSED=$((PASSED + FILE_PASSED))
                  FAILED=$((FAILED + FILE_FAILED))
                  SKIPPED=$((SKIPPED + FILE_SKIPPED))
                  
                  # Store per-project results
                  if [ -n "$PROJECT_RESULTS" ]; then
                    PROJECT_RESULTS="${PROJECT_RESULTS}|"
                  fi
                  PROJECT_RESULTS="${PROJECT_RESULTS}${PROJECT_NAME}:${FILE_TOTAL}:${FILE_PASSED}:${FILE_FAILED}:${FILE_SKIPPED}"
                fi
              fi
            done
          fi

          # Set outputs
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          echo "skipped=$SKIPPED" >> $GITHUB_OUTPUT
          echo "project_results=$PROJECT_RESULTS" >> $GITHUB_OUTPUT

          # Log results
          echo "::group::Test Results Summary"
          echo "Total:   $TOTAL"
          echo "Passed:  $PASSED"
          echo "Failed:  $FAILED"
          echo "Skipped: $SKIPPED"
          echo "Projects: $PROJECT_RESULTS"
          echo "::endgroup::"

          # Fail if tests failed
          if [ "$FAILED" -gt 0 ]; then
            echo "::error::$FAILED test(s) failed"
          fi
        shell: bash

      # ------------------------------------------------------------------------
      # Step 10: Upload test results artifact
      # ------------------------------------------------------------------------
      # Uploads TRX files as artifacts for download and analysis.
      # Retention: 14 days. Runs always to capture results even on test failures.
      # ------------------------------------------------------------------------
      - name: "üì§ Upload test results"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: deployment-test-results
          path: TestResults
          retention-days: 14
          if-no-files-found: warn

      # ------------------------------------------------------------------------
      # Step 11: Generate test report
      # ------------------------------------------------------------------------
      # Creates a test report with inline annotations for failed tests.
      # Uses dorny/test-reporter for rich GitHub integration with check runs.
      # Conditions: Runs always if TRX files exist, with fail-on-error disabled
      # to prevent blocking the pipeline on report generation issues.
      # ------------------------------------------------------------------------
      - name: "üìù Generate test report"
        uses: dorny/test-reporter@v1
        if: always() && hashFiles('TestResults/*.trx') != ''
        with:
          name: "Deployment - Unit Test Results"
          path: "TestResults/*.trx"
          reporter: dotnet-trx
          fail-on-error: false

      # ------------------------------------------------------------------------
      # Step 12: Gate - Check test results
      # ------------------------------------------------------------------------
      # Stops deployment if unit tests failed.
      # This is a critical gate to prevent deploying broken code to Azure.
      # If tests fail, the job fails here before any Azure provisioning begins.
      # Provides detailed diagnostic information for troubleshooting.
      # ------------------------------------------------------------------------
      - name: "üö® Gate: Check test results"
        if: steps.test.outcome == 'failure'
        run: |
          echo "::error::Unit tests failed. Deployment blocked."
          echo "## ‚ùå Deployment Blocked" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Unit tests failed. Fix test failures before deployment." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Add test failure details to summary
          TOTAL="${{ steps.test-results.outputs.total || '0' }}"
          PASSED="${{ steps.test-results.outputs.passed || '0' }}"
          FAILED="${{ steps.test-results.outputs.failed || '0' }}"

          echo "### üß™ Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
          echo "| ‚úÖ Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
          echo "| ‚ùå Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show failed test names from TRX files
          if [ -d "TestResults" ]; then
            echo "### ‚ùå Failed Tests" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            for trx in TestResults/*.trx; do
              if [ -f "$trx" ]; then
                FAILED_TESTS=$(grep -oP 'testName="\K[^"]+(?="[^>]*outcome="Failed")' "$trx" 2>/dev/null || true)
                if [ -n "$FAILED_TESTS" ]; then
                  echo "**$(basename "$trx" .trx)**:" >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  echo "$FAILED_TESTS" >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                fi
              fi
            done
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Next Steps:** Review the test report above or download the test artifacts for detailed failure information." >> $GITHUB_STEP_SUMMARY

          exit 1

      # ------------------------------------------------------------------------
      # Step 13: Setup Azure CLI and Bicep
      # ------------------------------------------------------------------------
      # Uses azure/cli action to run Azure CLI commands.
      # Installs Bicep CLI for template compilation and displays version.
      # No Azure authentication needed at this stage - only local validation.
      # ------------------------------------------------------------------------
      - name: "üîß Setup Azure CLI and Bicep"
        uses: azure/cli@v2
        with:
          inlineScript: |
            az --version
            az bicep install
            az bicep version

      # ------------------------------------------------------------------------
      # Step 14: Build Bicep templates
      # ------------------------------------------------------------------------
      # Validates infrastructure templates compile before provisioning.
      # Compiles the main template and all referenced modules.
      # This catches syntax errors before attempting Azure deployment.
      # ------------------------------------------------------------------------
      - name: "üèóÔ∏è Build Bicep templates"
        id: bicep-build
        uses: azure/cli@v2
        with:
          inlineScript: |
            echo "Building infra/main.bicep..."
            az bicep build --file infra/main.bicep --stdout > /dev/null
            echo "‚úÖ infra/main.bicep compiled successfully"

      # ------------------------------------------------------------------------
      # Step 15: Install Azure Developer CLI (azd)
      # ------------------------------------------------------------------------
      # Installs the latest version of azd for infrastructure management.
      # azd provides a unified experience for provisioning and deployment.
      # ------------------------------------------------------------------------
      - name: "üõ†Ô∏è Install Azure Developer CLI"
        uses: Azure/setup-azd@v2

      # ------------------------------------------------------------------------
      # Step 16: Install sqlcmd utility
      # ------------------------------------------------------------------------
      # Installs the Go version of sqlcmd for SQL Database managed identity
      # configuration in post-provisioning hooks.
      # continue-on-error: Installation failure doesn't block deployment.
      # ------------------------------------------------------------------------
      - name: "üõ†Ô∏è Install sqlcmd"
        run: |
          # Install sqlcmd (Go version) via direct download
          curl -sSL -o sqlcmd.tar.bz2 https://github.com/microsoft/go-sqlcmd/releases/latest/download/sqlcmd-linux-amd64.tar.bz2
          sudo tar -xjf sqlcmd.tar.bz2 -C /usr/local/bin
          rm sqlcmd.tar.bz2
          sqlcmd --version || echo "sqlcmd installation verification failed"
        continue-on-error: true

      # ------------------------------------------------------------------------
      # Step 17: Make hook scripts executable
      # ------------------------------------------------------------------------
      # Ensures shell scripts in hooks directory have execute permissions.
      # Required for azd lifecycle hooks to run on Linux runners.
      # ------------------------------------------------------------------------
      - name: "üîë Make hook scripts executable"
        run: chmod +x ./hooks/*.sh

      # ------------------------------------------------------------------------
      # Step 18: Authenticate Azure CLI (OIDC)
      # ------------------------------------------------------------------------
      # Uses OpenID Connect (OIDC) federated credentials for passwordless auth.
      # No secrets are stored in GitHub - authentication is handled via
      # Azure AD workload identity federation.
      #
      # Prerequisites:
      #   1. App Registration with Federated Credential configured
      #   2. Federated credential subject: repo:<owner>/<repo>:environment:<env>
      #   3. Service Principal with appropriate RBAC roles
      # ------------------------------------------------------------------------
      - name: "üîê Authenticate Azure CLI (OIDC)"
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      # ------------------------------------------------------------------------
      # Step 19: Authenticate Azure Developer CLI
      # ------------------------------------------------------------------------
      # Authenticates azd using GitHub federated credentials provider.
      # Uses the same OIDC mechanism as Azure CLI for consistent auth.
      # ------------------------------------------------------------------------
      - name: "üîê Authenticate Azure Developer CLI (Federated Credentials)"
        run: |
          azd auth login \
            --client-id "$AZURE_CLIENT_ID" \
            --federated-credential-provider "github" \
            --tenant-id "$AZURE_TENANT_ID"
        shell: bash

      # ------------------------------------------------------------------------
      # Step 20: Provision Azure Infrastructure
      # ------------------------------------------------------------------------
      # Deploys infrastructure using Bicep templates defined in /infra.
      # --no-prompt: Runs non-interactively for CI/CD automation.
      #
      # Resources provisioned (defined in infra/main.bicep):
      #   - Azure Container Apps Environment
      #   - Azure Container Registry
      #   - Azure Key Vault
      #   - Azure Logic Apps (Standard)
      #   - Supporting networking and monitoring resources
      # ------------------------------------------------------------------------
      - name: "‚òÅÔ∏è Provision Azure Infrastructure"
        run: azd provision --no-prompt
        env:
          # Override environment name if provided via workflow dispatch
          AZURE_ENV_NAME: ${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}

      # ------------------------------------------------------------------------
      # Step 21: Re-authenticate Azure Developer CLI (Token Refresh)
      # ------------------------------------------------------------------------
      # OIDC tokens have a short validity window (~5 minutes).
      # Provisioning may take 15-20+ minutes, causing the original token to expire.
      # Re-authenticating ensures a fresh token is available for deployment.
      # ------------------------------------------------------------------------
      - name: "üîê Re-authenticate Azure Developer CLI (Token Refresh)"
        run: |
          azd auth login \
            --client-id "$AZURE_CLIENT_ID" \
            --federated-credential-provider "github" \
            --tenant-id "$AZURE_TENANT_ID"
        shell: bash

      # ------------------------------------------------------------------------
      # Step 22: Deploy Application
      # ------------------------------------------------------------------------
      # Deploys application code to provisioned Azure resources.
      # Uses .NET Aspire manifest for service discovery and configuration.
      # Outputs the webapp URL for environment link in GitHub.
      #
      # Deployed services (defined in azure.yaml):
      #   - eShop.Orders.API: REST API for order management
      #   - eShop.Web.App: Frontend web application
      # ------------------------------------------------------------------------
      - name: "üö¢ Deploy Application"
        id: deploy
        run: |
          azd deploy --no-prompt
          # Output the web app URL for environment link
          echo "webapp_url=$(azd env get-values --output json | jq -r '.WEBAPP_URL // empty')" >> $GITHUB_OUTPUT
        shell: bash
        env:
          AZURE_ENV_NAME: ${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}

      # ------------------------------------------------------------------------
      # Step 23: Generate Deployment Summary
      # ------------------------------------------------------------------------
      # Creates a GitHub Actions job summary with deployment details.
      # Includes: build validation status, test metrics, deployment details,
      # and run information (environment, region, branch, commit, actor).
      # Runs always to provide visibility even on failures.
      # ------------------------------------------------------------------------
      - name: "üìã Generate Deployment Summary"
        if: always()
        run: |
          # Get test results from earlier step
          TOTAL="${{ steps.test-results.outputs.total || '0' }}"
          PASSED="${{ steps.test-results.outputs.passed || '0' }}"
          FAILED="${{ steps.test-results.outputs.failed || '0' }}"
          SKIPPED="${{ steps.test-results.outputs.skipped || '0' }}"
          PROJECT_RESULTS="${{ steps.test-results.outputs.project_results || '' }}"

          # Determine test status
          if [ "$FAILED" -gt 0 ]; then
            TEST_STATUS="‚ùå $FAILED Failed"
          elif [ "$TOTAL" -eq 0 ]; then
            TEST_STATUS="‚ö†Ô∏è No Tests"
          else
            TEST_STATUS="‚úÖ $PASSED Passed"
          fi

          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üèóÔ∏è Build Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| .NET Build | ‚úÖ Compiled |" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | $TEST_STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "| Bicep Build | ‚úÖ Validated |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show test details if tests ran
          if [ "$TOTAL" -gt 0 ]; then
            echo "### üß™ Test Results Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚úÖ Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚ùå Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
            echo "| ‚è≠Ô∏è Skipped | $SKIPPED |" >> $GITHUB_STEP_SUMMARY
            if [ "$TOTAL" -gt 0 ]; then
              PASS_PCT=$((PASSED * 100 / TOTAL))
              echo "| **Pass Rate** | $PASS_PCT% |" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "### üìä Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ job.status == 'success' && '‚úÖ Success' || job.status == 'cancelled' && '‚ö†Ô∏è Cancelled' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | \`${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Region** | \`${{ vars.AZURE_LOCATION }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Subscription** | \`${{ vars.AZURE_SUBSCRIPTION_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Run Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered By** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger Event** | \`${{ github.event_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit SHA** | [\`${GITHUB_SHA:0:7}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}) |" >> $GITHUB_STEP_SUMMARY
          echo "| **Workflow Run** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "### ‚úÖ Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The application has been deployed to the **${{ github.event.inputs.environment || vars.AZURE_ENV_NAME }}** environment." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ job.status }}" = "cancelled" ]; then
            echo "### ‚ö†Ô∏è Deployment was cancelled" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Deployment failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> **Troubleshooting:** Check the logs above for error details." >> $GITHUB_STEP_SUMMARY
          fi
        shell: bash
